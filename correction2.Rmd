---
title: "TP bioregionalisation avec les réseaux"
author: "Boris Leroy, UMR BOREA, Muséum National d'Histoire Naturelle"
output: html_document
editor_options: 
  chunk_output_type: inline
---


# 1. Chargement des données (bases poissons et polygones spatialisés des bassins)

```{r}
# Packages
library(biogeonetworks)
library(rgdal)
library(plyr)
library(RColorBrewer)

# Répertoire de travail
# setwd("d:/r/projects/Cours_Bioregionalisation/")

# Shapefiles
basins <- readOGR("./data/data_cours/basin2013_simplif.shp")

# Occurrence databases
load("./data/data_cours/fishdb1.RData")
load("./data/data_cours/fishdb2.RData")
```



# 2. Créer le réseau biogéographique


```{r}
writePajek(fishdb1, 
           site.field = "Basin",
           species.field = "Species",
           filename = "./data/fishdb1.net")
```


# 3. Appliquer l'algorithme de clusterisation

```{r}
system("./infomap --undirected --tree --map ./data/fishdb1.net ./data/")
```


# 4. Lire l'arbre et les clusters créés par Map Equation sous R

```{r}
fish.net1 <- readInfomapTree("./data/fishdb1.tree")
```

La fonction nous informe que le réseau a une hiérarchie de 5 niveaux, avec 15 clusters identifiés au niveau 1.


# 5. Analyser séparément les sites et les espèces

```{r}
fish.sites1 <- getSiteTable(fishdb1, site.field = "Basin", network = fish.net1)
fish.species1 <- getSpeciesTable(fishdb1, species.field = "Species", network = fish.net1)

head(fish.sites1)
count(fish.sites1$lvl1)
count(fish.species1$lvl1)
```

On observe que les 15 clusters du niveau 1 sont hétérogènes. Certains clusters contiennent beaucoup de bassins et sont très riches, tandis que d'autres ont peu de bassins et sont peu riches. S'agissant d'étudier les grandes régions biogéographiques, nous allons limiter notre analyse aux clusters qui ont beaucoup de bassins et beaucoup d'espèces. Les 6 premiers clusters ont plus de 50 bassins versants et plus de 200 espèces, donc nous travaillerons avec ces 6 clusters ici, mais vous pouvez choisir un chiffre différent (et vos résultats peuvent différer - MapEquation fonctionne sur un processus aléatoire donc il faut faire des répétitions, [cf. tutorial en ligne](https://github.com/Farewe/biogeonetworks)).

Le chiffre que vous choisirez n'a pas beaucoup d'impact à ce stade car il va servir aux couleurs sur les cartes (les clusters principaux seront colorés, tandis que les clusters secondaires seront en gris dans notre exemple).

# 6. Attribuer des couleurs aux grandes régions


```{r}
fish.net1 <- attributeColors(fish.net1, nb.max.colors = 6, db = fishdb1)
fish.sites1 <- attributeColors(fish.sites1, nb.max.colors = 6, db = fishdb1)
```


# 7. Affichez la carte des bassins avec les couleurs des régions

```{r}
basins@data$color1 <- fish.net1$color[match(basins@data$BASIN, fish.net1$Name)]
plot(basins, col = basins@data$color1)
```


# 8. Ecrire le réseau biogéographique pour Gephi


```{r}
writeGDF(fishdb1, fish.net1, site.field = "Basin", species.field = "Species", color.field = "color",
         filename = "./data/fishnet1.gdf")
```



# 9. Analysez le réseau biogéographique sous gephi

# 10. Refaites l'analyse pour la seconde base de données

```{r}
writePajek(fishdb2, 
           site.field = "Basin",
           species.field = "Species",
           filename = "./data/fishdb2.net")

system("./infomap --undirected --tree --map ./data/fishdb2.net ./data/")

fish.net2 <- readInfomapTree("./data/fishdb2.tree")


fish.sites2 <- getSiteTable(fishdb2, site.field = "Basin", network = fish.net2)
fish.species2 <- getSpeciesTable(fishdb2, species.field = "Species", network = fish.net2)

head(fish.sites2)
count(fish.sites2$lvl1)
count(fish.species2$lvl1)

fish.net2 <- attributeColors(fish.net2, nb.max.colors = 6, db = fishdb2)
fish.sites2 <- attributeColors(fish.sites2, nb.max.colors = 6, db = fishdb2)

basins@data$color2 <- fish.net2$color[match(basins@data$BASIN, fish.net2$Name)]

op <- par(mfrow = c(2, 1), mar = c(1.1, 1.1, 1.1, 1.1))
plot(basins, col = basins@data$color1)
plot(basins, col = basins@data$color2)
par(op)

writeGDF(fishdb2, fish.net2, site.field = "Basin", species.field = "Species", color.field = "color",
         filename = "./data/fishnet2.gdf")
```


**Qu'est-ce qui peut expliquer la différence entre les deux bases de données ?**

La différence est due au fait que la base fishdb2 intègre les occurrences d'introduction par l'homme des poissons d'eau douce, ce qui masque les patrons naturels et change la forme des régions biogéographiques de poissons d'eau douce.

# 11. (facultatif) Calculez le coefficient de participation.

```{r eval=FALSE}
fish.net1 <- participationCoefficient(fish.net1, 
                                      db = fishdb1, site.field = "Basin",
                                      species.field = "Species",
                                      lvl = "lvl1")
fish.net2 <- participationCoefficient(fish.net2, 
                                      db = fishdb2, site.field = "Basin",
                                      species.field = "Species",
                                      lvl = "lvl1")
rbPal <- colorRampPalette(c('blue','red'))
fish.net1$pcCol <- rbPal(10)[as.numeric(cut(fish.net1$participation.coef, breaks = 10))]
basins@data$pcCol1 <- fish.net1$pcCol[match(basins@data$BASIN, fish.net1$Name)]
fish.net2$pcCol <- rbPal(10)[as.numeric(cut(fish.net2$participation.coef, breaks = 10))]
basins@data$pcCol2 <- fish.net2$pcCol[match(basins@data$BASIN, fish.net2$Name)]

op <- par(mfrow = c(2, 1), mar = c(1.1, 1.1, 1.1, 1.1))
plot(basins, col = basins@data$pcCol1)
plot(basins, col = basins@data$pcCol2)
par(op)

```


Ajoutez le coefficient de participation à votre table attributaire des bassins, et visualisez le coefficient de participation.

# 12. (facultatif) Faites une belle carte :) 

```{r}
library(sf)
library(lwgeom)
library(ggplot2)
library(rnaturalearth)

# On va utiliser la projection du National Geographic: Winkel Tripel
# Pour cela il faut utiliser le package lwgeom qui permet des projections additionnelles avec sf

# Graticule
gr <- sf::st_graticule(lat = c(-89.9,seq(-80,80,20), 89.9))
# Projection du graticule en wintri
gr <- st_transform_proj(gr, 
                        crs = "+proj=wintri")

# Trait de cote
wm <- ne_coastline(scale = 50, returnclass = "sf")
# Projection
wm <- st_transform_proj(wm, 
                        crs = "+proj=wintri")


# Transformation des bassins en objet sf
basinsf <- st_as_sf(basins)
# Projection des bassins en wintri
basinsf <- st_transform_proj(basinsf, 
                             crs = "+proj=wintri")

# RICHNESS NATIVE
ggplot() +
  geom_sf(data = gr, color = 'grey', # graticule
          size = .5) +
  geom_sf(data = wm, col = grey(.6), fill = grey(.9), # continents
          size = .2) +
  geom_sf(data = basinsf, aes(fill = color1), # bassins avec couleurs des régions
          size = .05) +
  theme_minimal() + # thème simplifié pour ggplot2
  coord_sf(datum = NA) + # obligatoire pour pouvoir utiliser les projections de lwgeom
  scale_fill_identity()  # pour que ggplot utilise bien les couleurs qu'on lui demande

```


